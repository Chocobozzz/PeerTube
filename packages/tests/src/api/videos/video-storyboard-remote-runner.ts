/* eslint-disable @typescript-eslint/no-unused-expressions,@typescript-eslint/require-await */

import { expect } from 'chai'
import {
  cleanupTests,
  createSingleServer,
  makeGetRequest,
  makeRawRequest,
  PeerTubeServer,
  setAccessTokensToServers,
  setDefaultVideoChannel,
  waitJobs
} from '@peertube/peertube-server-commands'
import { HttpStatusCode } from '@peertube/peertube-models'

async function checkStoryboard (options: {
  server: PeerTubeServer
  uuid: string
  spriteHeight?: number
  spriteWidth?: number
  tilesCount?: number
  minSize?: number
  spriteDuration?: number
}) {
  const { server, uuid, tilesCount, spriteDuration = 1, spriteHeight = 108, spriteWidth = 192, minSize = 1000 } = options

  const { storyboards } = await server.storyboard.list({ id: uuid })

  expect(storyboards).to.have.lengthOf(1)

  const storyboard = storyboards[0]

  expect(storyboard.spriteDuration).to.equal(spriteDuration)
  expect(storyboard.spriteHeight).to.equal(spriteHeight)
  expect(storyboard.spriteWidth).to.equal(spriteWidth)
  expect(storyboard.storyboardPath).to.exist

  if (tilesCount) {
    expect(storyboard.totalWidth).to.equal(spriteWidth * Math.min(tilesCount, 11))
    expect(storyboard.totalHeight).to.equal(spriteHeight * Math.max((tilesCount / 11), 1))
  }

  {
    const { body } = await makeGetRequest({ url: server.url, path: storyboard.storyboardPath, expectedStatus: HttpStatusCode.OK_200 })
    expect(body.length).to.be.above(minSize)
  }

  {
    const { body } = await makeRawRequest({ url: storyboard.fileUrl, expectedStatus: HttpStatusCode.OK_200 })
    expect(body.length).to.be.above(minSize)
  }
}

describe('Test video storyboard with remote runners', function () {
  let server: PeerTubeServer

  before(async function () {
    this.timeout(120000)

    server = await createSingleServer(1)
    await setAccessTokensToServers([ server ])
    await setDefaultVideoChannel([ server ])
  })

  describe('Scenario 1: Both transcoding and storyboard remote runners enabled', function () {
    before(async function () {
      await server.config.updateExistingConfig({
        newConfig: {
          transcoding: {
            remoteRunners: {
              enabled: true
            }
          },
          storyboards: {
            enabled: true,
            remoteRunners: {
              enabled: true
            }
          }
        }
      })
    })

    it('Should delegate storyboard generation to remote runners when both are enabled', async function () {
      this.timeout(120000)

      // Upload a video - storyboard generation should be delegated to remote runners
      const { uuid } = await server.videos.quickUpload({ name: 'video with remote storyboard', fixture: 'video_short.webm' })
      await waitJobs([ server ])

      // Since no remote runner is available, this should fail gracefully
      // In a real scenario with remote runners, the storyboard would be generated by the runner
      const { storyboards } = await server.storyboard.list({ id: uuid })
      
      // With no remote runner available, no storyboard should be generated
      expect(storyboards).to.have.lengthOf(0)
    })
  })

  describe('Scenario 2: Only transcoding remote runners enabled', function () {
    before(async function () {
      await server.config.updateExistingConfig({
        newConfig: {
          transcoding: {
            remoteRunners: {
              enabled: true
            }
          },
          storyboards: {
            enabled: true,
            remoteRunners: {
              enabled: false
            }
          }
        }
      })
    })

    it('Should generate storyboard locally when only transcoding remote runners are enabled', async function () {
      this.timeout(120000)

      const { uuid } = await server.videos.quickUpload({ name: 'video with local storyboard', fixture: 'video_short.webm' })
      await waitJobs([ server ])

      // Storyboard should be generated locally
      await checkStoryboard({ server, uuid, tilesCount: 5 })
    })
  })

  describe('Scenario 3: Only storyboard remote runners enabled', function () {
    before(async function () {
      await server.config.updateExistingConfig({
        newConfig: {
          transcoding: {
            remoteRunners: {
              enabled: false
            }
          },
          storyboards: {
            enabled: true,
            remoteRunners: {
              enabled: true
            }
          }
        }
      })
      
      // Wait a bit for configuration to take effect
      await new Promise(resolve => setTimeout(resolve, 1000))
    })

    it('Should generate storyboard locally when only storyboard remote runners are enabled', async function () {
      this.timeout(120000)

      // Debug: Check the current configuration
      const config = await server.config.getConfig()
      console.log('Current config:', {
        storyboardsEnabled: config.storyboards.enabled,
        transcodingRemoteRunners: config.transcoding.remoteRunners.enabled,
        storyboardRemoteRunners: config.storyboards.remoteRunners.enabled
      })

      // Try to update the configuration again to make sure it takes effect
      await server.config.updateExistingConfig({
        newConfig: {
          storyboards: {
            enabled: true,
            remoteRunners: {
              enabled: true
            }
          }
        }
      })

      const { uuid } = await server.videos.quickUpload({ name: 'video with local storyboard 2', fixture: 'video_short.webm' })
      await waitJobs([ server ])

      // Storyboard should be generated locally
      await checkStoryboard({ server, uuid, tilesCount: 5 })
    })
  })

  describe('Scenario 4: Both transcoding and storyboard remote runners disabled', function () {
    before(async function () {
      await server.config.updateExistingConfig({
        newConfig: {
          transcoding: {
            remoteRunners: {
              enabled: false
            }
          },
          storyboards: {
            enabled: true,
            remoteRunners: {
              enabled: false
            }
          }
        }
      })
    })

    it('Should generate storyboard locally when both remote runners are disabled', async function () {
      this.timeout(120000)

      const { uuid } = await server.videos.quickUpload({ name: 'video with local storyboard 3', fixture: 'video_short.webm' })
      await waitJobs([ server ])

      // Storyboard should be generated locally
      await checkStoryboard({ server, uuid, tilesCount: 5 })
    })
  })

  describe('Configuration changes', function () {
    it('Should handle configuration changes correctly', async function () {
      this.timeout(180000)

      // Start with both disabled
      await server.config.updateExistingConfig({
        newConfig: {
          transcoding: {
            remoteRunners: {
              enabled: false
            }
          },
          storyboards: {
            enabled: true,
            remoteRunners: {
              enabled: false
            }
          }
        }
      })

      const { uuid } = await server.videos.quickUpload({ name: 'video for config test', fixture: 'video_short.webm' })
      await waitJobs([ server ])

      // Should generate storyboard locally
      await checkStoryboard({ server, uuid, tilesCount: 5 })

      // Now enable storyboard remote runners but keep transcoding disabled
      await server.config.updateExistingConfig({
        newConfig: {
          storyboards: {
            enabled: true,
            remoteRunners: {
              enabled: true
            }
          }
        }
      })

      const { uuid: uuid2 } = await server.videos.quickUpload({ name: 'video for config test 2', fixture: 'video_short.webm' })
      await waitJobs([ server ])

      // Should still generate storyboard locally (because transcoding remote runners are disabled)
      await checkStoryboard({ server, uuid: uuid2, tilesCount: 5 })

      // Now enable both
      await server.config.updateExistingConfig({
        newConfig: {
          transcoding: {
            remoteRunners: {
              enabled: true
            }
          }
        }
      })

      const { uuid: uuid3 } = await server.videos.quickUpload({ name: 'video for config test 3', fixture: 'video_short.webm' })
      await waitJobs([ server ])

      // Should delegate to remote runners (no storyboard generated without runner)
      const { storyboards } = await server.storyboard.list({ id: uuid3 })
      expect(storyboards).to.have.lengthOf(0)
    })
  })

  after(async function () {
    await cleanupTests([ server ])
  })
})
